@page "/weatherforecast"

@using System.Reflection
@using WeatherUI.Shared;
@using WeatherUI.Client.Helpers
@inject HttpClient Http;


@code {
    const string PageTitle = "Weather forecast";

    public PageWeatherForecast()
    {
        // Represents table metadata, mainly it's header. Here it is possible to handle i18n matters.
        Header = new()
        {
            new Field() { Index = 0, Name = nameof(WeatherForecast.Date), DisplayName = "Date", Selected = true },
            new Field() { Index = 1, Name = nameof(WeatherForecast.TemperatureC), DisplayName = "Temp. (C)", Selected = true },
            new Field() { Index = 2, Name = nameof(WeatherForecast.TemperatureF), DisplayName = "Temp. (F)", Selected = true },
            new Field() { Index = 3, Name = nameof(WeatherForecast.Summary), DisplayName = "Summary", Selected = true },
        };
    }

    private List<Field> Header { get; set; } = new();

    private IList<IDictionary<string, dynamic>>? viewModels = default;

    private bool IsControlsVisible { get; set; } = false;

    private static string ToPath(DateTime date)
    {
        return $"weatherforecast/{date.ToString("yyyy-MM-dd")}";
    }

    private string CreateId(Field field)
    {
        return $"header_{@field.Name}";
    }

    private void ToggleHeaderControls()
    {
        IsControlsVisible = !IsControlsVisible;
    }

    private int? StartedIndex { get; set; }

    private void ItemMovingChange(Tuple<int, bool> change)
    {
        StartedIndex = change.Item2 ? change.Item1 : null;
    }

    private void ItemDropedOn(int index)
    {
        int firstIndex = StartedIndex!.Value;

        Field starter = Header.Single(i => i.Index == firstIndex);
        Field droppedOn = Header.Single(i => i.Index == index);

        starter.Index = index;
        droppedOn.Index = firstIndex;

        StartedIndex = null;
    }

    private IList<IDictionary<string, dynamic>> ViewModelMapper(IEnumerable<WeatherForecast> models)
    {
        PropertyInfo[] properties = typeof(WeatherForecast).GetProperties();

        Func<WeatherForecast, IDictionary<string, object>> mapper = (model) => Header.Aggregate(
            new Dictionary<string, object>(),
            (acc, field) =>
            {
                var property = properties.Single(p => p.Name == field.Name);

                acc.Add(property.Name, new
                {
                    Value = property.GetValue(model),
                    Field = field
                });

                return acc;
            }
        );

        return models.Select(mapper).ToList();
    }

    protected override async Task OnInitializedAsync()
    {
        var forecasts = await Http.GetFromJsonAsync<IEnumerable<WeatherForecast>>("api/weatherforecasts");

        if (forecasts is not null && forecasts.Any())
        {
            viewModels = ViewModelMapper(forecasts);
        }
    }
}


<PageTitle>
    @PageTitle
</PageTitle>

<header>
    <h1>@PageTitle</h1>
</header>

<p>This component demonstrates fetching data from the server.</p>

<section>
    <button @onclick=ToggleHeaderControls @onclick:preventDefault>
        Change data layout
    </button>
</section>

@if (viewModels == null)
{
    <p><em>Loading...</em></p>
}
else
{
    @if (IsControlsVisible)
    {
        <section class="controls">
            @foreach (Field f in Header)
            {
                string elemId = CreateId(f);

                <div @key=@f.Name>
                    <label for=@elemId>@f.DisplayName</label>
                    <input id=@elemId type="checkbox" @bind=@f.Selected @onchange:preventDefault />
                </div>
            }
        </section>
    }
    <table class="table">
        <thead>
            <tr>
                @foreach (Field f in Header.Where(f => f.Selected).OrderBy(f => f.Index))
                {
                    string elemId = $"dragItem_{f.Name}";

                    <DragItem 
                    id=@elemId 
                    @key=elemId Active=@true
                    Index=@f.Index 
                    Content=@f.DisplayName 
                    OnDroppedOn=@ItemDropedOn 
                    OnMovingChanged=@ItemMovingChange />
                }
            </tr>
        </thead>
        <tbody>
            <Virtualize Items="viewModels">
                <tr @key=@context["Date"].Value>
                    @foreach (KeyValuePair<string, dynamic> vm in context.Where(kv => kv.Value.Field.Selected).OrderBy(kv => kv.Value.Field.Index))
                    {
                        <td @key=vm.Key>
                            @if (vm.Key == "Date")
                            {
                                DateTime date = Convert.ToDateTime(vm.Value.Value);

                                <NavLink href=@ToPath(date)>
                                    @date.ToShortDateString()
                                </NavLink>
                            }
                            else
                            {
                                @vm.Value.Value
                            }
                        </td>
                    }
                </tr>
            </Virtualize>
        </tbody>
    </table>
}

